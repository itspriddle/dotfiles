#!/usr/bin/env bash
# Usage: ical-week [-n] [-N[COUNT] | -P[COUNT]] [--] [YYYY-MM-DD]
#
# NAME
#   ical-week -- print the week number according to Calendar.app
#
# SYNOPSIS
#   ical-week [-n] [-N[COUNT] | -P[COUNT]] [--] [YYYY-MM-DD]
#
# DESCRIPTION
#   Prints the week number according to Calendar.app on macOS, which differs
#   from the "%U", "%W", and "%V" formats of strftime(3).
#
# OPTIONS
#   -n, --no-pad
#     If set, no prepending 0 is used with single digit week numbers (i.e. Jan
#     1st will return "1" instead of "01").
#
#   -L[COUNT], --last[=COUNT]
#     If set, shows the previous week's number. Specify a COUNT to go back
#     further.
#
#   -N[COUNT], --next[=COUNT]
#     If set, shows the next week's number. Specify a COUNT to go forward
#     further.
#
# SEE ALSO
#   DATE(1), STRFTIME(3)

# Call this script with DEBUG=1 to add some debugging output
if [[ "$DEBUG" ]]; then
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -x
fi

set -e

# Echoes given args to STDERR
#
# $@ - args to pass to echo
warn() {
  echo "$@" >&2
}

# Reformats the given date
#
# $1 - source date (default in %Y-%m-%d format)
# $2 - new format to output (not including the +, default %Y-%m-%d)
# $3 - source date format (default is %Y-%m-%d)
reformat_date() {
  local now="$1" new_fmt="${2-%F}" src_fmt="${3-%F}"

  date -j -f "$src_fmt" "$now" "+$new_fmt"
}

# Advance a date by weeks forward or backward
#
# $1 - date in %Y-%m-%d format
# $2 - weeks to offset, including + or -
advance_date() {
  local now="$1" offset="$2"

  date -v "$offset" -j -f "%F" "$now" "+%F"
}

# Prints the Calendar.app week number
#
# $1 - date in %Y-%m-%d format
# $2 - pad string to use with printf (i.e. "" or "02")
#
# Note: I know what you're thinking... "Hey, look at this clown, calculating
# the week number by hand instead of reaching for `date` and '%U', '%W' or
# '%V'. He probably didn't even RTFM!" Well, you're right, I didn't really
# peruse `man date` much until I saw that Calendar.app's week number did not
# match those from strftime(3). I promise, I wanted this entire monstrosity to
# be a one-liner. But, alas, computers.
#
# Anyway, if you've read this far, gather 'round and let me tell you a tale of
# week numbers on macOS.
#
# Calendar.app does not use ISO 8601 unless a user changes their calendar
# setting in System Preferneces -> Language & Region to ISO 8601. That's
# probably The Right Thing To Doâ„¢, but I don't want to have to change system
# preferences to get the week number that Calendar.app is using.
#
# This means that week numbers in Calendar.app do not match those obtained by
# programming languages that use strftime(3) (i.e. `%V` and `%U` in `date`
# or Ruby's `Time#strftime`):
#
#   - %U: is replaced by the week number of the year (Sunday as the first day
#         of the week) as a decimal number (00-53). Calendar.app never returns
#         Week 0, and fixing it is not as simple as adding 1.
#
#   - %V: is replaced by the week number of the year (Monday as the first day
#         of the week) as a decimal number (01-53). If the week containing
#         January 1 has four or more days in the new year, then it is Week 1;
#         otherwise it is the last week of the previous year, and the next
#         week is Week 1.
#
#   - %W: is replaced by the week number of the year (Monday as the first day
#         of the week) as a decimal number (00-53), basically a Monday-based
#         version of `%U`.
#
# These options are not appropriate to obtain the week number used by
# Calendar.app. Instead, January 1 is Week 1 *always*, which consequently
# means Week 53 only occurs in Calendar.app if December 31 is a Sunday.
#
# The days that `date` considers start of week for its various week number
# options also complicate things.
#
#   - %U: is close to what we want. Its week starts on Sunday like we want,
#         but it uses Week 53 and Week 0. We can't just increase it by 1
#         either.
#   - %V: would be a perfect match if the user sets ISO 8601 in their
#         preferences. Its week also starts on a Monday.
#   - %W: is also close to what we want, like %U, but its week starts on a
#         Monday.
#
# With all that in mind, we calculate the week number as follows:
#
# 1. The "unadjusted" week number is calculated by...
#   a. Obtaining the ordinal date (i.e. the day of the year 1-366)
#   b. Obtaining the current day of week (i.e. 1-7, 1=Sun)
#   c. Calculating `(10 + DAY_OF_YEAR - (DAY_OF_WEEK)) / 7` (remainder is
#      ignored)
# 2. The day of week for January 1 this year is obtained.
# 3. If January 1 fell Thursday through Saturday, the week number reported by
#    `date '+%U'` will be off by -1! In this case, the week number is adjusted
#    by adding 1 to account for missing week. This also happens when
#    `date '+%U'` thinks it is Week 0. This adjustment solves that problem as
#    well.
# 4. If the adjusted week is > 52 and December 31 is not on a Saturday, it is
#    really week 1.
# 5. Otherwise, the adjusted week is correct.
#
# See https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_from_a_month_and_day_of_the_month_or_ordinal_date
week_number() {
  local now="$1" pad="$2" week offset ord dow year_end_dow year_start_dow

  ord="$(reformat_date "$now" "%-j")"
  dow="$(reformat_date "$now" "%w")"
  year_start_dow="$(reformat_date "$(reformat_date "$now" "%Y")-01-01" "%w")"
  offset="$(printf "%d" "$(( year_start_dow > 4 ))")"
  week="$(( ( ( 10 + ord - (dow + 1) ) / 7 ) + offset ))"
  year_end_dow="$(reformat_date "$(reformat_date "$now" "%Y")-12-31" "%w")"

  # If it's W53 and the 12/31 doesn't fall on a Saturday, then it is really
  # W1...
  if [[ "$week" -gt 52 ]] && [[ "$year_end_dow" -ne 6 ]]; then
    printf "%${pad}d" 1
  else
    printf "%${pad}d" "$week"
  fi
}

# Print the help text for this program
#
# $1 - flag used to ask for help ("-h" or "--help")
print_help() {
  sed -ne '/^#/!q;s/^#$/# /;/^# /s/^# //p' < "$0" |
    awk -v f="${1#-h}" '!f&&/^Usage:/||u{u=!/^\s*$/;if(!u)exit}u||f'
}

main() {
  local target_date pad="02" advance

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help) print_help "$1"; return 0 ;;
      -n | --no-pad) pad= ; shift ;;
      -N | --next) advance="+1"; shift ;;
      -N[0-9]*) advance="+${1:2}"; shift ;;
      --next=*) advance="+${1#*=}"; shift ;;
      -P | --prev) advance="-1"; shift ;;
      -P[0-9]*) advance="-${1:2}"; shift ;;
      --prev=*) advance="-${1#*=}"; shift ;;
      --) shift; break ;;
      *) break ;;
    esac
  done

  : "${target_date:="${1:-$(date "+%F")}"}"

  if ! [[ "$target_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    warn "Invalid date! Use YYYY-MM-DD format!"
    return 1
  fi

  if [[ "$advance" ]]; then
    target_date="$(advance_date "$target_date" "${advance}w")"
  fi

  week_number "$target_date" "$pad" && [[ -t 1 ]] && echo
}

main "$@"
