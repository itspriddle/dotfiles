#!/usr/bin/env ruby

require "stringio"
require "optparse"
require "uri"
require "date"
require "time"
require "json"
require "shellwords"

class Date
  def start_of_week
    self - wday
  end

  def end_of_week
    self + (6 - wday)
  end

  def next_week
    self + 7
  end

  def last_week
    self - 7
  end

  def start_of_month
    self.class.new(year, month, 1)
  end

  def end_of_month
    if month == 12
      self.class.new(year + 1, 1, 1) - 1
    else
      self.class.new(year, month + 1, 1) - 1
    end
  end
end

class Time
  def start_of_day
    self.class.parse strftime("%Y-%m-%d 00:00:00 %z")
  end

  def end_of_day
    self.class.parse strftime("%Y-%m-%d 23:59:59 %z")
  end
end

class Schedule
  attr_reader :time, :schedule, :calendars

  def initialize(time:, calendars: :all)
    @time      = time
    @calendars = calendars
  end

  def to_markdown
    out = StringIO.new

    meeting_count = schedule.inject(0) { |sum, (date, events)|
      sum + events.select { |e| e[:duration] }.size
    }

    meeting_total = schedule.inject(0) { |sum, (date, events)|
      sum + events.sum { |e| e[:duration] || 0 }
    }
    meeting_total = (meeting_total / 60.0).round(2)

    # TODO: "this week" isn't accurate
    if time.first.to_date != time.last.to_date
      out.puts "---"
      out.puts "---"
      out.puts
      out.puts "# #{time.first.year} Notes"
      out.puts
      out.puts "## Overview"
      out.puts
      out.puts "Good morning!"
      out.puts
      out.puts "You have **#{meeting_count} meetings** this week, totaling **#{meeting_total} hours.**"
      out.puts
      out.puts "---"
      out.puts
    end

    schedule.each do |date, events|
      output = events.select { |e| e[:duration] }.map.with_index(1) do |event, index|
        time     = event[:start_time]
        title    = event[:title]
        duration = " `#{event[:duration]}m`" if event[:duration]
        links    = "[Meet](#{event[:meet]})" if event[:meet]

        [index, "#{time}#{duration}", title, links].map(&:to_s)
      end.compact

      meeting_count = events.count { |e| e[:duration] }
      meeting_count = "no" if meeting_count == 0

      time_total = events.inject(0) { |sum, e| sum + e[:duration].to_i }
      time_total = (time_total / 60.0).round(2)
      time_total = "%d" % time_total if time_total.round == time_total

      out.puts "## #{date.strftime("%a, %b %-d")}"
      out.puts

      out.puts "You have **%s** scheduled today, totaling **%s**." % [
        "#{meeting_count} meeting#{meeting_count == 1 ? "" : "s"}",
        "#{time_total} hour#{time_total == 1 ? "" : "s"}",
      ]
      out.puts

      all_day = events.reject { |e| e[:start_time] }

      if all_day.any?
        one = all_day.one?

        out.puts "> **All-Day Events**"
        out.puts ">"

        all_day.each do |event|
          out.puts "> - #{event[:title]}"
        end

        out.puts
      end

      unless output.empty?
        out.puts MarkdownTable.generate(
          headers: %W(# Time Title Links),
          rows:    output
        )

        out.puts
      end

      out.puts "---"
      out.puts
    end

    out.string
  end

  def to_json
    schedule.to_json
  end

  def schedule
    @schedule ||= CalendarDriver.find_events(time, calendars: calendars).lines.each_with_object({}) do |line, out|
      raw_title, raw_date, raw_notes = *line.split(CalendarDriver::PS)

      /\A(?<title>.*) \((?<calendar>.*)\)\z/ =~ raw_title

      if raw_date =~ / at /
        date, raw_time       = *raw_date.split(" at ")
        start_time, end_time = *raw_time.split(" - ")
        date                 = Date.parse(date)
        start_time           = Time.parse("#{date} #{start_time}:00")
        end_time             = Time.parse("#{date} #{end_time}:00")
        duration             = (end_time.to_i - start_time.to_i) / 60
        start_time           = start_time.strftime("%-l:%M%P")
        end_time             = end_time.strftime("%-l:%M%P")
      else
        date       = Date.parse(raw_date)
        start_time = nil
        end_time   = nil
        duration   = nil
        time       = nil
      end

      notes = raw_notes.to_s.gsub(CalendarDriver::NL, "\n")

      urls = URI.extract(notes, %w(http https)).reject { |url|
        url == "https:/" || # weird Google Calendar artifact
          url.start_with?("https://tel.meet/")
      }.uniq

      meet = urls.find { |u| u.start_with? "https://meet.google.com/" }

      out[date] ||=[]

      # Avoid duplicates if you have shared calendar events on your personal
      # calendar as well
      if out[date].any? { |event| event[:title] == title && event[:meet] == meet }
        next
      end

      out[date] << {
        title:      title,
        calendar:   calendar,
        date:       date,
        start_time: start_time,
        end_time:   end_time,
        duration:   duration,
        notes:      notes,
        meet:       meet,
        urls:       urls,
      }
    end
  end
end

class CalendarDriver
  PS = "#ICALBUDDY-PROPERTY-SEPARATOR#"
  NL = "#ICALBUDDY-NEW-LINE#"

  def self.installed?
    `type "icalBuddy" &> /dev/null`

    $?.success?
  end

  def self.require!
    unless installed?
      abort "Missing icalBuddy! Install it with \`brew install ical-buddy`"
    end
  end

  def self.run(*args)
    require!

    `icalBuddy #{args.join(" ")}`.chomp.tap do
      abort "icalBuddy error" unless $?.success?
    end
  end

  def self.find_events(target, calendars:)
    args = %W(
      --noRelativeDates
      --dateFormat "%Y-%m-%d"
      --timeFormat "%H:%M"
      --bullet ""
      --propertySeparators "|#{PS}|"
      --includeEventProps title,datetime,notes
      --propertyOrder title,datetime,notes
      --noPropNames
      --notesNewlineReplacement "#{NL}"
      eventsFrom:#{Shellwords.escape(target.first)}
      to:#{Shellwords.escape(target.last)}
    )

    args.prepend %(--includeCals "#{calendars.join(",")}") if calendars.any?

    run *args
  end
end

class MarkdownTable
  def self.generate(headers:, rows:)
    lengths = headers.each_with_index.map do |header, index|
      # Minimum cell width is 3 chars
      [3, header.bytesize, *rows.map { |r| r[index].bytesize }].max
    end

    [].tap { |output|
      output << lengths.each_with_index.map { |length, index|
        "%-#{length}s" % headers[index]
      }

      output << lengths.each_with_index.map { |length, index|
        "-" * length
      }

      rows.each do |cols|
        output << cols.each_with_index.map { |col, index|
          "%-#{lengths[index]}s" % col
        }
      end
    }.map { |row| row.join(" | ").prepend("| ").concat(" |") }.join("\n")
  end
end

return unless $0 == __FILE__

begin
  options = {
    format:    "markdown",
    from:      Date.today.start_of_week.to_time.start_of_day,
    until:     Date.today.end_of_week.to_time.end_of_day,
    calendars: [],
  }

  OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} [options]"

    opts.on "-cCALENDARS", "--calendars CALENDARS", "Comma separated list of calendar names to fetch events from" do |calendars|
      options[:calendars] = calendars.to_s.split(",")
    end

    opts.on "-FFMT", "--format FMT", "Output format (json or markdown)" do |format|
      options[:format] = format
    end

    opts.on "-fDATE", "--from DATE", "Include events starting from the given date" do |date|
      options[:from] = Time.parse(date).start_of_day
    end

    opts.on "-uDATE", "--until DATE", "Include events ending on the given date" do |date|
      options[:until] = Time.parse(date).end_of_day
    end

    opts.on "-w", "--week", "Show events for this week" do
      options[:from] = Date.today.start_of_week.to_time.start_of_day
      options[:until] = Date.today.end_of_week.to_time.end_of_day
    end

    opts.on "-W", "--next-week", "Show events for next week" do
      options[:from] = Date.today.next_week.start_of_week.to_time.start_of_day
      options[:until] = Date.today.next_week.end_of_week.to_time.end_of_day
    end

    opts.on "-t", "--today", "Show events for today" do
      options[:from] = Date.today.to_time.start_of_day
      options[:until] = Date.today.to_time.end_of_day
    end

    opts.on "-T", "--tomorrow", "Show events for tomorrow" do
      options[:from] = Date.today.next.to_time.start_of_day
      options[:until] = Date.today.next.to_time.end_of_day
    end

    opts.on "-d", "--days DAYS", "Show events for today through the given number of days" do |days|
      options[:from] = Date.today.to_time.start_of_day
      options[:until] = (Date.today + [days.to_i - 1, 0].max).to_time.end_of_day
    end

    # TODO: shows last days of the month due to icalBuddy
    opts.on "-m", "--month", "Show events for this month" do
      options[:from] = Date.today.start_of_month.to_time.start_of_day
      options[:until] = Date.today.end_of_month.to_time.end_of_day
    end

    # TODO: use icalBuddy eventsNow ?
    # opts.on "-n", "--now", "Now" do
    #   options[:now] = true
    # end

    opts.on "--console", "Load this script in an IRB console" do
      options[:console] = true
    end

    opts.on "-h", "--help", "Print this help and exit" do
      puts opts
      exit
    end
  end.parse!
rescue OptionParser::InvalidOption, OptionParser::MissingArgument => e
  abort e.message
rescue ArgumentError => e
  abort "Invalid date format!"
end

if options[:console]
  require "irb"
  IRB.start
  exit
end

target = if options[:from] && options[:until]
           options[:from]..options[:until]
         else
           abort "Must specify a date!"
         end

schedule = Schedule.new(
  time:      target,
  calendars: options[:calendars]
)

case options[:format]
when "json"
  puts schedule.to_json
else
  puts schedule.to_markdown
end

# vim:ft=ruby
