#!/usr/bin/env bash
# Usage: slack-notify [options] [message]
#        echo "Message" | slack-notify [options]
#        slack-notify -F "Field Title|Body" [options]
#
# NAME
#   slack-notify -- send notifications via old school Slack webhook
#
# SYNOPSIS
#   slack-notify [options] [message]
#   echo "Message" | slack-notify [options]
#   slack-notify -F "Field Title|Body" [options]
#
# DESCRIPTION
#   Sends an old school Slack webhook.
#
#   Without the `-F` / `--field` option, a standard text message sent to the
#   webhook, either as the first argument or STDIN.
#
#   Text Example:
#     $ slack-notify "This is a message"
#     $ echo "This is a message | slack-notify"
#
#   When `-F` / `--field` is used, a message with fields is sent to the
#   webhook. Fields have a title and a value. The option can be used more than
#   once. The argument to `-F` / `--field` is a string, separated by the `-s`
#   / `--separator` character (`|` by default).
#
#   Slack allows specifying long or short fields. If multiple short fields are
#   sent, they will be displayed in 2 columns in Slack clients. Long fields
#   span both columns. Fields are marked short by default or when the title is
#   prefixed with `short:`. Fields are marked long when the title is prefixed
#   with `long:`.
#
#   The following options have no effect when sending a message with fields:
#     -f / --fallback
#     -p / --pretext
#     -c / --color
#     -s / --separator
#     --footer
#
#   Fields Example:
#     $ slack-notify --field "Name|Josh" --field "Editor|Vim"
#
# OPTIONS
#   -w URL, --webhook-url URL
#       Slack webhook URL. Required.
#
#   -r RECIPIENT, --recipient RECIPIENT
#       Slack channel/user to send the message to. If not supplied, the
#       default channel configured on the webhook is used by Slack.
#
#   -i ICON, --icon ICON
#       Icon to use, either an emoji code like `:megaphone:`, or an image URL.
#       If not supplied, the default icon configured on the webhook is used by
#       Slack.
#
#   -u USER, --user USER
#       User to send the message as. If not supplied, the default user
#       configured on the webhook is used by Slack.
#
#   -F FIELD, --field FIELD
#       Send a message field in the format where FIELD is one of the following
#       formats:
#
#       - Title|Value
#       - long:Title|Value
#       - short:Title|Value
#
#       The field separator `|` character can be customized with the `-s` /
#       `--separator` option.
#
#   -s SEPARATOR, --separator SEPARATOR
#       Separator to use for fields to separate the title from the value.
#       Defaults to `|`.
#
#   -f FALLBACK, --fallback FALLBACK
#       Fallback text to send. This is displayed in notifications. Ignored if
#       at least one field is not supplied with `-F` / `--field`.
#
#   -p PRETEXT, --pretext PRETEXT
#       Message pretext, displayed above the fieldset. Ignored if at least one
#       field is not supplied with `-F` / `--field`.
#
#   -c COLOR, --color COLOR
#       Color of the fieldset in CSS hex format (i.e. `#FF0000`). Ignored if at
#       least one field is not supplied with `-F` / `--field`.
#
#   --footer FOOTER
#       Footer text, displayed below the fieldset. Ignored if at least one
#       field is not supplied with `-F` / `--field`.
#
#   --print-payload
#       Print the Slack payload instead of sending it.
#
#   -h, --help
#       Print this help message.
#
# SENDING MESSAGE FIELDS (AKA MESSAGE ATTACHMENTS)
#   The old style webhooks allow you to send fields (eg: message attachments
#   in Slack documentation, but *not* file attachments). The `--field` or `-F`
#   option above can be used to send a message with fields.
#
# EXAMPLES
#   Send a simple text notification
#   $ slack-notify "Warning, something broke"
#
#   Or use a multi-line body
#   $ slack-notify "Subject
#
#   This is the body"
#
#   Using STDIN
#   $ { echo "Subject"; echo "Errors"; tail -5 /var/log/messages } | slack-notify
#   $ slack-notify
#   This is a message
#   ^d
#
#   Using fields
#   $ slack-notify \
#       --field "Alert Type|Warning" \
#       --field "Alert Text|Uh oh..." \
#       --field "long:Body|Something blew up" \
#       --fallback "Warning: Uh oh... Something blew up" \
#       --pretext "An Error Occurred" \
#       --footer "<https://example.com|Ticket>" \
#       --color FF0000

if [[ "$DEBUG" ]]; then
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -x
fi

# Sends a notification via Slack
#
# $1 - Webhook URL (required)
# $2 - JSON Payload (required)
send_slack() {
  local webhook_url="$1"
  local payload="$2"

  curl --silent --data @- "$webhook_url" <<< "$payload"
}

main() {
  local message recipient result fallback pretext color footer icon user print_payload fields=()

  local payload='{}'

  local fs=$'\t'
  local fs='|'

  # I have an internal proxy on this address to my actual Slack webhook.
  # If you are stealing this script from me, you can set your own or just
  # leave it blank.
  local webhook_url="https://slack.priddle.network"

  while [[ "$1" ]]; do
    case "$1" in
      -r|--recipient)
        recipient="$2"
        shift 2
        ;;
      -w|--webhook-url)
        webhook_url="$2"
        shift 2
        ;;
      -h|--help)
        sed -ne '/^#/!q;s/^#$/# /;/^# /s/^# //p' < "$0" |
          awk -v f="${1#-h}" '!f && /^Usage:/ || u { u=!/^\s*$/; if (!u) exit } u || f'
        return 0
        ;;
      -F|--field)
        fields+=("$2")
        shift 2
        ;;
      -f|--fallback)
        fallback="$2"
        shift 2
        ;;
      -p|--pretext)
        pretext="$2"
        shift 2
        ;;
      -c|--color)
        color="${2#\#}"
        shift 2
        ;;
      -s|--separator)
        fs="$2"
        shift 2
        ;;
      --footer)
        footer="$2"
        shift 2
        ;;
      -i|--icon)
        icon="$2"
        shift 2
        ;;
      -u|--user)
        user="$2"
        shift 2
        ;;
      --print-payload)
        print_payload=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "Unknown option: $1" >&2
        return 1
        ;;
      *)
        break
        ;;
    esac
  done

  if ! command -v jq >/dev/null; then
    echo "jq is required" >&2
    return 1
  elif ! command -v curl >/dev/null; then
    echo "curl is required" >&2
    return 1
  fi

  if [[ -z "$webhook_url" ]]; then
    echo "Webhook URL is required" >&2
    return 1
  fi

  if [[ "${#fields}" -gt 0 ]] && [[ "$#" -gt 0 ]]; then
    echo "Cannot send both fields and a message argument" >&2
    return 1
  fi

  if [[ "${#fields}" -gt 0 ]]; then
    local raw_field need_fallback fields_json="[]"

    [[ -z "$fallback" ]] && need_fallback=1

    for raw_field in "${fields[@]}"; do
      local title value field_json short="true"

      if [[ "$raw_field" =~ ^(long|short): ]]; then
        [[ "${raw_field:0:4}" = long ]] && short="false"

        raw_field="${raw_field#*:}"
      fi

      title="${raw_field%$fs*}"
      value="${raw_field#*$fs}"

      [[ "$need_fallback" ]] && fallback+="$title: $value"$'\n'

      field_json=$(
        jq -n \
          --arg title "$title" \
          --arg value "$value" \
          --argjson short "$short" \
        '[{"title": $title, "value": $value, "short": $short}]'
      )

      fields_json+=" $field_json"
    done

    [[ "$need_fallback" ]] && fallback="${fallback%$'\n'}"

    # TODO: allow sending multiple attachments.
    # Maybe do:
    #   $0 \
    #     --field "Hi|There" \
    #     --color ff0000 \
    #     [---|--close-attachment]
    #     --field "Hi|There" \
    #     --color ff0000
    #
    # Or:
    #   $0 \
    #     --field1 "Attachment 1 Field 1|Blah" \
    #     --field1 "Attachment 1 Field 2|Blah" \
    #     --color1 ff0000 \
    #     --footer1 Footer \
    #     --field2 "Attachment 2 Field 1|Blah" \
    #     --field2 "Attachment 2 Field 2|Blah" \
    #     --color2 00ff00 \
    #     --footer2 Footer2 \
    #
    # Would need to refactor arg loop and reset all options when `---` is
    # found.
    payload=$(
      jq \
        --arg fallback "$fallback" \
        --arg pretext "$pretext" \
        --arg color "${color:+#}$color" \
        --arg footer "$footer" \
        --argjson fields "$(jq -s add <<< "$fields_json")" \
        '. += {
            "attachments": [
              {
                "fallback": $fallback,
                "pretext": $pretext,
                "color": $color,
                "footer": $footer,
                "fields": $fields,
                "mrkdwn_in": ["fields", "text", "pretext", "footer"],
              } | with_entries(
                select(.value |
                  if type == "array" then . != [] else . != "" end
                )
              )
            ]
          }
        ' <<< "$payload"
      )
  else
    message="${1:-$(cat)}"

    if [[ -z "$message" ]] && [[ "${#fields}" -eq 0 ]]; then
      echo "Must supply message or --field" >&2
      return 1
    fi

    payload=$(jq --arg message "$message" '. += { "text": $message }' <<< "$payload")
  fi

  if [[ "${icon-}" =~ ^:.*:$ ]]; then
    payload=$(jq --arg icon "$icon" '. += { "icon_emoji": $icon }' <<< "$payload")
  elif [[ -n "${icon-}" ]]; then
    payload=$(jq --arg icon "$icon" '. += { "icon_url": $icon }' <<< "$payload")
  fi

  if [[ "$recipient" ]]; then
    payload=$(jq --arg channel "$recipient" '. += { "channel": $channel }' <<< "$payload")
  fi

  if [[ "${user-}" ]]; then
    payload=$(jq --arg user "$user" '. += { "username": $user }' <<< "$payload")
  fi

  if [[ "$print_payload" ]]; then
    jq <<< "$payload"
    return 0
  fi

  result=$(send_slack "$webhook_url" "$payload")

  if [[ "$result" != "ok" ]]; then
    echo "Error: $result" >&2
    return 1
  fi
}

main "$@"
