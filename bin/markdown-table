#!/usr/bin/env bash
# Usage: markdown-table -COLUMNS [CELLS]
#        markdown-table -sSEPARATOR < file
#
# NAME
#   markdown-table -- FIXME
#
# SYNOPSIS
#   markdown-table -COLUMNS [CELLS]
#   markdown-table -sSEPARATOR < file
#
# DESCRIPTION
#   FIXME
#
# OPTIONS
#   -COLUMNS
#
#   -s
#
#   --csv
#
#   --tsv
#
#   -h, --help
#
# EXAMPLES
#   markdown-table -4 \
#     "Heading 1"  "Heading 2" "Heading 3" "Heading 4" \
#     "Hi"         "There"     "From"      "Markdown!" \
#     "Everything" "Is"        "So"        "Nicely Aligned!"
#
#   markdown-table -s, < some.csv
#   markdown-table --csv < some.csv
#
#   markdown-table -s$'\t' < test.tsv
#   markdown-table --tsv < test.tsv
#
# SEE ALSO
#   FIXME

# Call this script with DEBUG=1 to add some debugging output
if [[ "$DEBUG" ]]; then
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -x
fi

set -e

# Echoes given args to STDERR
#
# $@ - args to pass to echo
warn() {
  echo "$@" >&2
}

# Print the help text for this program
#
# $1 - flag used to ask for help ("-h" or "--help")
print_help() {
  sed -ne '/^#/!q;s/^#$/# /;/^# /s/^# //p' < "$0" |
    awk -v f="$1" '
      f == "-h" && ($1 == "Usage:" || u) {
        u=1
        if ($0 == "") {
          exit
        } else {
          print
        }
      }
      f != "-h"
      '
}

# Returns the highest number in the given arguments
#
# $@ - one or more numeric arguments
max() {
  local max=0 arg

  for arg; do
    (( ${arg:-0} > max )) && max="$arg"
  done

  printf "%s" "$max"
}

# Formats a table in markdown format
#
# $1 - field seprator string
format_table() {
  local fs="$1" buffer col current_col=0 current_row=0 min=3
  local -a lengths=()

  buffer="$(cat)"

  # First pass to get column lengths
  while read -r line; do
    current_col=0

    while read -r col; do
      lengths["$current_col"]="$(max "${#col}" "${lengths[$current_col]}")"

      current_col=$((current_col + 1))
    done <<< "${line//$fs/$'\n'}"
  done <<< "$buffer"

  # Second pass writes each row
  while read -r line; do
    current_col=0

    while read -r col; do
      printf "| "
      printf "%-$(max "${lengths[$current_col]}" "$min")s" "$col"
      printf " "

      current_col=$((current_col + 1))
    done <<< "${line//$fs/$'\n'}"

    printf "|\n"

    # If this is the first row, print the header dashes
    if [[ "$current_row" -eq 0 ]]; then
      for (( current_col=0; current_col < ${#lengths[@]}; current_col++ )); do
        printf "| "
        printf "%$(max "${lengths[$current_col]}" "$min")s" | tr " " -
        printf " "
      done

      printf "|\n"
    fi

    current_row=$((current_row + 1))
  done <<< "$buffer"
}

# Main program
main() {
  local arg cols i fs="##$$FS##"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help) print_help "$1"; return 0 ;;
      -[0-9]*) cols="${1:1}"; shift ;;
      -s*) fs="${1:2}"; shift ;;
      --csv) fs=","; shift ;;
      --tsv) fs=$'\t'; shift ;;
      --) shift; break ;;
      -*) warn "Invalid option '$1'"; return 1 ;;
      *) break ;;
    esac
  done

  if [[ -z "$fs" ]]; then
    warn "Field separator can't be blank!"
    return 1
  elif [[ $# -gt 0 ]] && ! [[ "$cols" =~ ^[0-9]+$ ]]; then
    warn "Missing or Invalid column count!"
    return 1
  fi

  { if [[ $# -gt 0 ]]; then
      for arg; do
        for (( i=0; i < cols; i++ )); do
          printf "%s%s"  "$1" "$fs"
          shift
        done

        printf "\n"
      done | sed "s/$fs\$//g"
    else
      cat
    fi
  } | format_table "$fs"
}

main "$@"
